

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/LinPresonBlog/img/favicon.png">
  <link rel="icon" href="/LinPresonBlog/img/favicon.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Mr.Lin">
  <meta name="keywords" content="">
  
  <title>数据库底层原理 - 博客</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/LinPresonBlog/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/LinPresonBlog/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"lin15849376843.github.io","root":"/LinPresonBlog/","version":"1.8.11","typing":{"enable":true,"typeSpeed":150,"cursorChar":"","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/LinPresonBlog/js/utils.js" ></script>
  <script  src="/LinPresonBlog/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/LinPresonBlog/">&nbsp;<strong>Mr.Lin</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/LinPresonBlog/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/LinPresonBlog/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/LinPresonBlog/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/LinPresonBlog/about/">
                <i class="iconfont icon-user-fill"></i>
                关于我
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/LinPresonBlog/img/post_banner.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="数据库底层原理">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-08-20 06:45" pubdate>
        2021年8月20日 早上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      10.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      117
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">数据库底层原理</h1>
            
            <div class="markdown-body">
              <h1 id="数据库底层原理（mySql）"><a href="#数据库底层原理（mySql）" class="headerlink" title="数据库底层原理（mySql）"></a>数据库底层原理（mySql）</h1><h3 id="一、MySQL-的基本定义："><a href="#一、MySQL-的基本定义：" class="headerlink" title="一、MySQL 的基本定义："></a>一、MySQL 的基本定义：</h3><h4 id="A．术语介绍"><a href="#A．术语介绍" class="headerlink" title="A．术语介绍"></a>A．术语介绍</h4><h5 id="1-数据库（Database）"><a href="#1-数据库（Database）" class="headerlink" title="1. 数据库（Database）"></a>1. 数据库（Database）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">是按照数据结构来组织、存储和管理数据的仓库。<br>每个数据库都有一个或多个不同的API用于创建、访问、管理、搜索和复制所保存的数据。<br></code></pre></td></tr></table></figure>

<h5 id="2-RDBMS（Relational-Database-Management-System）"><a href="#2-RDBMS（Relational-Database-Management-System）" class="headerlink" title="2. RDBMS（Relational Database Management System）"></a>2. RDBMS（Relational Database Management System）</h5><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">关系数据库管理系统，由瑞典MySQL AB公司开发，目前属于<span class="hljs-keyword">Oracle公司。</span><br><span class="hljs-keyword">是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。</span><br></code></pre></td></tr></table></figure>

<h6 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">数据以表格的形式出现。<br>每行为各种记录名称。<br>每列为记录名称所对应的数据域。<br>许多的行和列组成一张表单。<br>若干的表单组成<span class="hljs-keyword">Database</span>。<br></code></pre></td></tr></table></figure>

<h6 id="RDBMS术语："><a href="#RDBMS术语：" class="headerlink" title="RDBMS术语："></a>RDBMS术语：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">数据库： 数据库是一些关联表的集合。<br>数据表： 表示数据的矩阵。<br>列： 一列（数据元素）包含了相同类型的数据。<br>行： 一行是一组相关的数据。<br>冗余： 存储两倍数据，冗余降低了性能，但提高了数据的安全性。<br>主键： 主键是唯一的，一个数据表中只能包含一个主键。<br>外键： 外键用于关联两个表。<br>复合键： 复合键（组合键）将多个列作为一个索引键，一般用于复合索引。<br>索引： 使用索引可快速访问数据库表中的特定信息，索引是对数据库表中一列或多列的值进行排序的一种结构。<br>参照完整性： 参照完整性要求关系中不允许引用不存在的实体，与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性。<br></code></pre></td></tr></table></figure>

<h4 id="B．MySQL常用命令"><a href="#B．MySQL常用命令" class="headerlink" title="B．MySQL常用命令"></a>B．MySQL常用命令</h4><h5 id="1-管理MySQL的命令"><a href="#1-管理MySQL的命令" class="headerlink" title="1. 管理MySQL的命令"></a>1. 管理MySQL的命令</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">MySQL的用户设置，只需要在MySQL数据库中的<span class="hljs-keyword">user</span>表中添加新用户即可。（use mysql; <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">user</span>() <span class="hljs-keyword">values</span>()）。<br><br>USE  数据库名 ：选择要操作的MySQL数据库，使用该命令后所有MySQL命令都只针对该数据库。<br><span class="hljs-keyword">SHOW</span> DATABASES ：列出MySQL数据库管理系统的数据库列表。<br><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">TABLES</span> ：显示指定数据库的所有表，使用该命令前需要使用use命令来选择要操作的数据库。<br><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">COLUMNS</span> <span class="hljs-keyword">FROM</span> 数据表名 ：显示数据表的属性，属性类型，主键信息，是否<span class="hljs-keyword">NULL</span>，默认值等其它信息。<br><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">FROM</span> 数据表名 ： 显示数据表的详细索引信息，包括 <span class="hljs-keyword">PRIMARY KEY</span>（主键）。<br><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">TABLE</span> STATUS <span class="hljs-keyword">FROM</span> 数据库名 <span class="hljs-keyword">LIKE</span> ‘pattern’\G  ：该命令输出MySQL数据库管理系统的性能及统计信息。<br></code></pre></td></tr></table></figure>

<h5 id="2-MySQL的基本命令"><a href="#2-MySQL的基本命令" class="headerlink" title="2. MySQL的基本命令"></a>2. MySQL的基本命令</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">DATABASE</span> 数据库名：创建数据库。（或者使用root权限创建：mysqladmin -u root -p <span class="hljs-keyword">create</span>数据库名）。<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">DATABASE</span> 数据库名：删除数据库。（或者使用root权限删除：mysqladmin -u root -p <span class="hljs-keyword">drop</span> 数据库名）。<br><br><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 数据库名：获取创建数据表（<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span>）语句，该语句包含了原数据表的结构、索引。<br></code></pre></td></tr></table></figure>

<h6 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> tb_name （<span class="hljs-built_in">column_name</span> column_type）；<br>例：<br><span class="hljs-keyword">create</span> tale tb_student(<br>    s_id  <span class="hljs-type">int</span>  <span class="hljs-keyword">PRIMARY KEY</span>  AUTO_INCREMENT,<br>    s_name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>)  <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    s_sex <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>),<br>    s_age <span class="hljs-type">int</span><br>)ENGINE=InnoDB  <span class="hljs-keyword">DEFAULT</span> CHARSET=utf8;<br><br><span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> ：在操作数据库时如果输入该字段的数据为<span class="hljs-keyword">NULL</span>，则报错。<br>AUTO_INCREMENT ：定义列为自增的属性，一般用于主键，数值会自动加<span class="hljs-number">1</span>。<br>PRIMARY_KEY ：定义列为主键，（也可以使用多列定义主键,以逗号分隔）（PRIMARY_KEY s_id, s_sex）。<br>ENGINE ：设置存储引擎，不定义则使用默认存储引擎（MySQL默认存储引擎是 InnoDB）。<br>CHARSET ：设置编码格式，默认是UTF<span class="hljs-number">-8</span>。<br></code></pre></td></tr></table></figure>

<h6 id="删除数据表"><a href="#删除数据表" class="headerlink" title="删除数据表"></a>删除数据表</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> tb_name；<br></code></pre></td></tr></table></figure>

<h6 id="删除表中字段"><a href="#删除表中字段" class="headerlink" title="删除表中字段"></a>删除表中字段</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> tb_name <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">column</span>;<br></code></pre></td></tr></table></figure>

<h6 id="向表中添加字段"><a href="#向表中添加字段" class="headerlink" title="向表中添加字段"></a>向表中添加字段</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> tb_name <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">column</span> 类型;          # 添加到最后一列。<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> tb_name <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">column</span> 类型 <span class="hljs-keyword">FIRST</span>;    # 添加到第一列。<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> tb_name <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">column</span> 类型 AFTER <span class="hljs-keyword">column</span>;  # 添加到某个字段之后。<br></code></pre></td></tr></table></figure>

<h6 id="修改字段类型及名称"><a href="#修改字段类型及名称" class="headerlink" title="修改字段类型及名称"></a>修改字段类型及名称</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> tb_name MODIFY <span class="hljs-keyword">column</span> 类型;    # 使用MODIFY修改。<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> tb_name CHANGE old_column new_column 类型；  # 使用CHANGE修改。<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> tb_name MODIFY <span class="hljs-keyword">column</span> 类型 <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">100</span>; # 指定字段非空，默认值<span class="hljs-number">100</span>。<br></code></pre></td></tr></table></figure>

<h6 id="修改字段默认值"><a href="#修改字段默认值" class="headerlink" title="修改字段默认值"></a>修改字段默认值</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> tb_name <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">column</span> <span class="hljs-keyword">SET</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">1000</span>;  # 修改字段默认值。<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> tb_name <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">column</span> <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">DEFAULT</span>;     # 删除字段默认值。<br></code></pre></td></tr></table></figure>

<h6 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> old_tb_name <span class="hljs-keyword">RENAME</span> <span class="hljs-keyword">TO</span> new_tb_name;<br></code></pre></td></tr></table></figure>

<h6 id="修改存储引擎"><a href="#修改存储引擎" class="headerlink" title="修改存储引擎"></a>修改存储引擎</h6><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ALTER TABLE tb_name engine=InnoDB<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<h6 id="修改外键约束"><a href="#修改外键约束" class="headerlink" title="修改外键约束"></a>修改外键约束</h6><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas"><span class="hljs-meta">ALTER</span> <span class="hljs-meta">TABLE</span> tb_name <span class="hljs-meta">DROP</span> <span class="hljs-meta">FOREIGN</span> <span class="hljs-meta">KEY</span> keyname;<br></code></pre></td></tr></table></figure>

<h6 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-built_in">table_name</span> (field1, field2, ……, fieldN)  <span class="hljs-keyword">VALUES</span> （value1, value2, ……, valueN）;<br></code></pre></td></tr></table></figure>

<h6 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">UPDATE</span> tb_name <span class="hljs-keyword">SET</span> field1=<span class="hljs-built_in">new</span>-value1, field2=<span class="hljs-built_in">new</span>-value2 <span class="hljs-keyword">WHERE</span> … ；<br><span class="hljs-keyword">WHERE</span>子句中可以指定任何条件。<br></code></pre></td></tr></table></figure>

<h6 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> <span class="hljs-built_in">table_name</span> <span class="hljs-keyword">WHERE</span> … ;<br><span class="hljs-keyword">WHERE</span> 子句中可以指定任何条件。<br></code></pre></td></tr></table></figure>

<h6 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> column_name1, column_name2 <span class="hljs-keyword">FROM</span> table_name1, table_name2 <br><span class="hljs-keyword">WHERE</span> [condition1 [<span class="hljs-keyword">AND</span> [<span class="hljs-keyword">OR</span>]] condition2 …… ；<br><br>查询语句中可以使用一个或者多个表，表之间使用逗号（，）分割，并使用<span class="hljs-keyword">WHERE</span>语句设定查询条件。<br><span class="hljs-keyword">WHERE</span> 子句中可以指定任何条件。<br>可以使用<span class="hljs-keyword">AND</span>或者<span class="hljs-keyword">OR</span>指定一个或多个条件。<br>可以使用<span class="hljs-keyword">LIKE</span>子句代替等号（=），<span class="hljs-keyword">LIKE</span>通常与（%）一同使用，类似于一个元字符的搜索（<span class="hljs-keyword">LIKE</span>“ACC%”）。<br><span class="hljs-keyword">WHERE</span>子句也可以运用<span class="hljs-keyword">SQL</span>的<span class="hljs-keyword">DELETE</span>或<span class="hljs-keyword">UPDATE</span>命令。<br>可以使用<span class="hljs-keyword">LIMIT</span>属性来设定返回的记录数。<br>可以使用<span class="hljs-keyword">OFFSET</span>指定<span class="hljs-keyword">SELECT</span>语句开始查询的数据偏移量，默认偏移量为<span class="hljs-number">0</span>。<br><span class="hljs-keyword">WHERE</span>子句类似于程序语言中的<span class="hljs-keyword">if</span>条件，根据MySQL表中的字段值来读取指定的数据。<br><br><span class="hljs-keyword">WHERE</span>子句操作符：<br>=        ：等于<br>&lt;&gt;, !=   ：不等于<br>&gt;        ：大于<br>&lt;        ：小于<br>&gt;=      ：大于等于<br>&lt;=      ：小于等于<br></code></pre></td></tr></table></figure>

<h6 id="UNION操作符"><a href="#UNION操作符" class="headerlink" title="UNION操作符"></a>UNION操作符</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UNION</span>操作符用于连接两个以上的<span class="hljs-keyword">SELECT</span>语句的结果组合到一个结果集合中。<br>多个<span class="hljs-keyword">SELECT</span>语句会删除重复的数据。<br><br><span class="hljs-keyword">SELECT</span> expression1, expression2, ……, expressionN <span class="hljs-keyword">FROM</span> tb_name1 <span class="hljs-keyword">WHERE</span> ……<br><span class="hljs-keyword">UNION</span>  [ <span class="hljs-keyword">ALL</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">DISTINCT</span> ]<br><span class="hljs-keyword">SELECT</span> expression1, expression2, ……, expressionN <span class="hljs-keyword">FROM</span> tb_name2 <span class="hljs-keyword">WHERE</span> ……;<br><br><span class="hljs-keyword">ALL</span> ：可选项，返回所有结果集，包含重复数据。<br><span class="hljs-keyword">DISTINCT</span> ：可选项，删除结果集中重复的数据。<br></code></pre></td></tr></table></figure>

<h6 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h6><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> ：对查询结果进行排序。<br><span class="hljs-keyword">SELECT</span> column1, column2 <span class="hljs-keyword">FROM</span> tb_name <span class="hljs-keyword">WHERE</span> …… <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> field1 [<span class="hljs-keyword">ASC</span>/<span class="hljs-keyword">DESC</span>]，field2 [<span class="hljs-keyword">ASC</span>/<span class="hljs-keyword">DESC</span>]。<br><br><span class="hljs-keyword">ASC</span>/<span class="hljs-keyword">DESC</span> ：升序/降序，默认<span class="hljs-keyword">ASC</span>。<br></code></pre></td></tr></table></figure>

<h6 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h6><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> ：对查询结果进行分组。<br><span class="hljs-keyword">SELECT</span> column1, column2 <span class="hljs-keyword">FROM</span> tb_name <span class="hljs-keyword">WHERE</span> …… <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> column1, column2。<br></code></pre></td></tr></table></figure>

<h6 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">JOIN</span>  ：在两个或多个表中查询数据。<br><br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span>（内连接，或等值连接）：获取两个表中字段匹配关系的记录。<br> 内连接使用比较运算符对两个表中的数据进行比较，并列出与连接条件匹配的数据行，组合成新的记录，结果只保留满足条件的记录。<br> <span class="hljs-keyword">SELECT</span> column1, … <span class="hljs-keyword">FROM</span> tb_name1 <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> tb_name2 <span class="hljs-keyword">ON</span> tb_name1.id <span class="hljs-operator">=</span> tb_name2.id;<br><br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span>（左连接）：获取左表所有记录，即使右表没有对应匹配的记录。<br>左表保持不动，右表在右侧滑动，用右表匹配左表，结果保留左表的所有行，右表中不匹配的行默认填充为空值<span class="hljs-keyword">NULL</span>。<br><span class="hljs-keyword">SELECT</span> column1, … <span class="hljs-keyword">FROM</span> tb_name1 <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> tb_name2 <span class="hljs-keyword">ON</span> tb_name1.id<span class="hljs-operator">=</span>tb_name2.id;<br><br><span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span>（右连接）：获取右表所有记录，即使左表没有对应匹配的记录。<br>右表保持不动，左表在左侧滑动，用左表匹配右表，结果保留右表的所有行，左表中不匹配的行默认填充为空值<span class="hljs-keyword">NULL</span>。<br><span class="hljs-keyword">SELECT</span> column1, … <span class="hljs-keyword">FROM</span> tb_name1 <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> tb_name2 <span class="hljs-keyword">ON</span> tb_name1.id<span class="hljs-operator">=</span>tb_name2.id;<br></code></pre></td></tr></table></figure>

<h6 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span> ：当列的值是<span class="hljs-keyword">NULL</span>，此运算符返回<span class="hljs-keyword">true</span>。<br><span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> ：当列的值不为<span class="hljs-keyword">NULL</span>，此运算符返回<span class="hljs-keyword">true</span>。<br>&lt;=&gt; ：比较操作符（不同于 = 运算符） ：当比较的两个值相等或者都为<span class="hljs-keyword">NULL</span>时，返回<span class="hljs-keyword">true</span>。<br></code></pre></td></tr></table></figure>

<h5 id="3-MySQL数据类型"><a href="#3-MySQL数据类型" class="headerlink" title="3. MySQL数据类型"></a>3. MySQL数据类型</h5><h6 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">MySQL中支持所有标准<span class="hljs-keyword">SQL</span>数值数据类型。<br>包括严格数值数据类型（<span class="hljs-type">INTEGER</span>，<span class="hljs-type">SMALLINT</span>，<span class="hljs-type">DECIMAL</span>，<span class="hljs-type">NUMERIC</span>）。<br>以及近似数值数据类型（<span class="hljs-type">FLOAT</span>，<span class="hljs-type">REAL</span>，<span class="hljs-type">DOUBLE</span> <span class="hljs-type">PRECISION</span>）。<br></code></pre></td></tr></table></figure>

<h6 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">表示时间值的日期和时间类型（DATETIME，<span class="hljs-type">DATE</span>，<span class="hljs-type">TIMESTAMP</span>，<span class="hljs-type">TIME</span>，<span class="hljs-keyword">YEAR</span>）。<br>每个时间类型有一个有效值范围和一个“零”值，当指定不合法的MySQL不能表示的值时使用“零”值。<br></code></pre></td></tr></table></figure>

<h6 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">字符串类型（<span class="hljs-type">CHAR</span>，<span class="hljs-type">VARCHAR</span>，<span class="hljs-type">BINARY</span>，<span class="hljs-type">VARBINARY</span>，<span class="hljs-type">BLOB</span>，TEXT，ENUM，<span class="hljs-keyword">SET</span>）。<br></code></pre></td></tr></table></figure>

<h5 id="4-MySQL索引"><a href="#4-MySQL索引" class="headerlink" title="4. MySQL索引"></a>4. MySQL索引</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">索引是应用在<span class="hljs-keyword">SQL</span>查询语句的条件，一般作为<span class="hljs-keyword">WHERE</span>子句的条件。<br><br>主键索引：数据列不允许重复，不允许为<span class="hljs-keyword">NULL</span>，一个表只能有一个主键。<br>普通索引：基本的索引类型，没有唯一性限制，允许为<span class="hljs-keyword">NULL</span>值。<br>唯一索引：索引列的值必须唯一，但允许有空值；如果是组合索引，则列值的组合必须唯一。<br>前缀索引：用列的前缀代替整个列作为索引key，比如：<span class="hljs-keyword">like</span>‘xxx%’。<br>Hash索引：采用一定的哈希算法，把键值换算成新的哈希值，只需一次哈希算法即可定位到相应的位置，查询速度非常快。<br></code></pre></td></tr></table></figure>

<h6 id="创建索引的三种方式"><a href="#创建索引的三种方式" class="headerlink" title="创建索引的三种方式"></a>创建索引的三种方式</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> indexName <span class="hljs-keyword">ON</span> tb_name(<span class="hljs-keyword">column</span>(length));   # 直接创建索引。<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> tb_name <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">INDEX</span> indexName(<span class="hljs-keyword">column</span>);    # 修改表结构时添加索引。<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> tb_name(                                  # 创建表的时候直接指定。<br>    id <span class="hljs-type">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    username <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-keyword">INDEX</span>  [indexName] (username(length))<br>);<br></code></pre></td></tr></table></figure>

<h6 id="创建唯一索引的三种方式"><a href="#创建唯一索引的三种方式" class="headerlink" title="创建唯一索引的三种方式"></a>创建唯一索引的三种方式</h6><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sas"><span class="hljs-meta">CREATE</span> <span class="hljs-meta">UNIQUE</span> <span class="hljs-meta">INDEX</span> indexName <span class="hljs-meta">ON</span> tb_name(colu<span class="hljs-meta">mn(</span><span class="hljs-meta">length</span>))；    # 直接创建索引。<br><span class="hljs-meta">ALTER</span> <span class="hljs-meta">TABLE</span> tb_name <span class="hljs-meta">ADD</span> <span class="hljs-meta">UNIQUE</span> [indexName] (colu<span class="hljs-meta">mn(</span><span class="hljs-meta">length</span>))；  # 修改表结构时创建索引。<br><span class="hljs-meta">CREATE</span> <span class="hljs-meta">TABLE</span> tb_name(                                             # 创建表时添加索引。<br>    id int <span class="hljs-meta">NOT</span> <span class="hljs-meta">NULL</span>,<br>    username VARCHAR(16) <span class="hljs-meta">NOT</span> <span class="hljs-meta">NULL</span>,<br>    <span class="hljs-meta">UNIQUE</span> [indexName] （username(<span class="hljs-meta">length</span>)）<br>);<br></code></pre></td></tr></table></figure>

<h6 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h6><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">INDEX</span> [indexName] <span class="hljs-keyword">ON</span> tb_name;<br></code></pre></td></tr></table></figure>

<h6 id="使用ALTER命令添加、删除索引"><a href="#使用ALTER命令添加、删除索引" class="headerlink" title="使用ALTER命令添加、删除索引"></a>使用ALTER命令添加、删除索引</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> tb_name <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">PRIMARY KEY</span> (<span class="hljs-keyword">column</span>);   # 该语句添加一个主键，索引值必须是唯一的，且不能为<span class="hljs-keyword">NULL</span>。<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> tb_name <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">UNIQUE</span> indexName (<span class="hljs-keyword">column</span>);  # 该语句创建索引的值必须是唯一的（除<span class="hljs-keyword">NULL</span>外）。<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> tb_name <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">INDEX</span> indexName (<span class="hljs-keyword">column</span>);     # 添加普通索引，索引值可出现多次。<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> tb_name <span class="hljs-keyword">ADD</span> FULLTEXT indexName (<span class="hljs-keyword">column</span>);  # 该语句指定索引为FULLTEXT，用于全文索引。<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> tb_name <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">column</span>;   # 删除索引。<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> tb_name <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">PRIMARY KEY</span> (<span class="hljs-keyword">column</span>);   # 添加主键。<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> tb_name <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PRIMARY KEY</span>;      # 删除主键。<br><br><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">FROM</span> tb_name;    # 显示索引信息。<br></code></pre></td></tr></table></figure>

<h6 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">查看执行计划，使用<span class="hljs-keyword">explain</span>关键字可以模拟优化器执行<span class="hljs-keyword">SQL</span>语句，查看使用到的索引列及其它信息。<br><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_name;<br></code></pre></td></tr></table></figure>

<h5 id="5-索引使用策略及优化"><a href="#5-索引使用策略及优化" class="headerlink" title="5. 索引使用策略及优化"></a>5. 索引使用策略及优化</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">最常用的索引底层存储结构是棵 <span class="hljs-selector-tag">B</span>- Tree 或 <span class="hljs-selector-tag">B</span>+ Tree。<br></code></pre></td></tr></table></figure>

<h6 id="索引有两种：单列索引-和-组合索引"><a href="#索引有两种：单列索引-和-组合索引" class="headerlink" title="索引有两种：单列索引 和 组合索引"></a>索引有两种：单列索引 和 组合索引</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">单列索引：一个索引只包含单个列，一个表可以有多个单列索引。<br>组合索引：一个索引包含多个列。<br><br>单列索引：一个索引只能有一个字段。<br>组合索引：也称复合索引，相对于单列索引，组合索引可以为多个字段创建一个索引。<br></code></pre></td></tr></table></figure>

<h6 id="最左前缀原理"><a href="#最左前缀原理" class="headerlink" title="最左前缀原理"></a>最左前缀原理</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sql">最左匹配就是最左边优先；创建组合索引时，要根据业务要求，<span class="hljs-keyword">where</span>子句中使用最频繁的一列放在最左边。<br>组合索引的查找是先根据第一个字段查，然后再根据第二个字段查，或者只根据第一个字段查，但是不能跳过第一个字段、直接从第二个字段开始查，这就是所谓的最左前缀原理。<br><br>第一个字段是有序的。<br>当第一个字段值相等的时候，第二个字段也是有序的。<br>当第一个字段值相等、第二个字段值也相等时，第三个字段也是有序的。<br><br>例：在字段 a, b, c上创建一个联合索引，索引顺序会首先按照a字段排序，然后再按照b字段排序，最后是c字段。<br>下面的<span class="hljs-keyword">SQL</span>语句是按照（（a），（a, b），（a, b, c））的顺序用到索引。<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_name <span class="hljs-keyword">where</span> a <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_name <span class="hljs-keyword">where</span> a <span class="hljs-operator">=</span> <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> b <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_name <span class="hljs-keyword">where</span> a <span class="hljs-operator">=</span> <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> b <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> c <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br>下面的<span class="hljs-keyword">SQL</span>语句只用到一个索引a 。<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_name <span class="hljs-keyword">where</span> a <span class="hljs-operator">=</span> <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> c <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br>下面的<span class="hljs-keyword">SQL</span>语句未使用到索引，因未遵循最左匹配原理。<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_name <span class="hljs-keyword">where</span> b <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> c <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br>以MySQL为例，下面的<span class="hljs-keyword">SQL</span>语句也能使用到索引，查询优化器会重新编译，不建议这样使用。<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_name <span class="hljs-keyword">where</span> b <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> c <span class="hljs-operator">=</span> <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> a <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>

<h6 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h6><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 主键、外键要建索引。<br><span class="hljs-bullet">2.</span> 对where, on, group by, order by中出现的列使用索引。<br><span class="hljs-bullet">3.</span> 最左匹配原则（重中之重）。<br><span class="hljs-bullet">4.</span> 尽量扩展索引；例：已经有a字段索引，现在要使用（a, b）字段的索引，只需修改原来的索引即可。<br><span class="hljs-bullet">5.</span> 不要过多创建索引，索引过多会影响插入、删除数据的速度。<br><span class="hljs-bullet">6.</span> 对于like查询，“%”不要放在前面。<br><span class="hljs-bullet">7.</span> where条件数据类型不匹配也无法使用索引。<br><span class="hljs-bullet">8.</span> 为较长的字符串使用前缀索引。<br><span class="hljs-bullet">9.</span> 对索引列进行函数运算时索引也会失效。<br></code></pre></td></tr></table></figure>

<h5 id="6-聚集索引-与-非聚集索引"><a href="#6-聚集索引-与-非聚集索引" class="headerlink" title="6. 聚集索引 与 非聚集索引"></a>6. 聚集索引 与 非聚集索引</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">聚集索引 与 非聚集索引底层引用的都是 <span class="hljs-selector-tag">B</span>+ 树索引。<br></code></pre></td></tr></table></figure>

<h6 id="聚集索引（clustered）"><a href="#聚集索引（clustered）" class="headerlink" title="聚集索引（clustered）"></a>聚集索引（clustered）</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">也叫聚簇索引，数据行的物理顺序与列值（主键）的逻辑顺序相同，一个表中只能拥有一个聚集索引。<br></code></pre></td></tr></table></figure>

<h6 id="非聚集索引（unclustered）"><a href="#非聚集索引（unclustered）" class="headerlink" title="非聚集索引（unclustered）"></a>非聚集索引（unclustered）</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引。<br></code></pre></td></tr></table></figure>

<h5 id="7-MySQL数据导入、导出（导入、导出文件需用户有FILE权限）"><a href="#7-MySQL数据导入、导出（导入、导出文件需用户有FILE权限）" class="headerlink" title="7. MySQL数据导入、导出（导入、导出文件需用户有FILE权限）"></a>7. MySQL数据导入、导出（导入、导出文件需用户有FILE权限）</h5><h6 id="常用导出数据语句"><a href="#常用导出数据语句" class="headerlink" title="常用导出数据语句"></a>常用导出数据语句</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> … <span class="hljs-keyword">INTO</span> OUTFILE<br>将一个数据库的数据写入一个文件，输出不能是一个已存在的文件。<br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> tb_name <span class="hljs-keyword">INTO</span> OUTFILE ‘/tmp/tmp.txt’;<br><br><span class="hljs-keyword">LOAD</span> DATA INFILE<br>将文件读回数据库。<br></code></pre></td></tr></table></figure>

<h6 id="常用导入数据语句"><a href="#常用导入数据语句" class="headerlink" title="常用导入数据语句"></a>常用导入数据语句</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">mysql命令导入<br>mysql  -u用户名  -p密码   &lt;   要导入的数据库数据（tmp.<span class="hljs-keyword">sql</span>）<br>例：mysql -uroot -p123456 &lt; tmp.<span class="hljs-keyword">sql</span>     # 将备份的整个数据库tmp.<span class="hljs-keyword">sql</span>导入<br><br>source 命令导入<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span> abc;           # 创建数据库。<br>use abc;                       # 使用已创建的数据库。<br><span class="hljs-keyword">set names</span> utf8;                # 设置编码。<br>source  /home/abc/abc.<span class="hljs-keyword">sql</span>;    # 导入备份数据库。<br><br><span class="hljs-keyword">LOAD</span> DATA命令导入<br><span class="hljs-keyword">LOAD</span> DATA <span class="hljs-keyword">LOCAL</span> INFILE ‘tmp.txt’ <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">TABLE</span> myTable<br>FIELDS TERMINATED <span class="hljs-keyword">BY</span> ‘:’<br>LINES TERMINATED <span class="hljs-keyword">BY</span> ‘\r\n’;     # 将tmp.txt文件中的数据导入myTable表中<br><br>如果指定<span class="hljs-keyword">LOCAL</span>关键词，则表明从客户主机上按路径读取文件。<br>如果没有指定，则文件在服务器上按路径读取文件。<br></code></pre></td></tr></table></figure>

<h3 id="二、数据库事务与并发性："><a href="#二、数据库事务与并发性：" class="headerlink" title="二、数据库事务与并发性："></a>二、数据库事务与并发性：</h3><h4 id="A．数据库事务"><a href="#A．数据库事务" class="headerlink" title="A．数据库事务"></a>A．数据库事务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">在MySQL中，只有使用了Innodb引擎的数据库或表才支持事务。<br></code></pre></td></tr></table></figure>

<h5 id="1-数据库事务定义"><a href="#1-数据库事务定义" class="headerlink" title="1. 数据库事务定义"></a>1. 数据库事务定义</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">事务处理可以用来维护数据库的完整性，保证<span class="hljs-keyword">SQL</span>语句要么全部执行，要么全部不执行。<br>事务用来管理 <span class="hljs-keyword">insert</span>, update, <span class="hljs-keyword">delete</span> 语句。<br></code></pre></td></tr></table></figure>

<h6 id="1）原子性（Atomicity，-或称不可分割性）"><a href="#1）原子性（Atomicity，-或称不可分割性）" class="headerlink" title="1）原子性（Atomicity， 或称不可分割性）"></a>1）原子性（Atomicity， 或称不可分割性）</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">一个事务中的操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。<br>事务在执行过程中发生错误，会被回滚到事务开始前的状态。<br></code></pre></td></tr></table></figure>

<h6 id="2）一致性（Consistency）"><a href="#2）一致性（Consistency）" class="headerlink" title="2）一致性（Consistency）"></a>2）一致性（Consistency）</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">在事务开始之前和事务结束之后，数据库的完整性没有被破坏。<br>这表示写入的资料必须完全符合所有的预设规则。<br></code></pre></td></tr></table></figure>

<h6 id="3）隔离性（Isolation，又称独立性）"><a href="#3）隔离性（Isolation，又称独立性）" class="headerlink" title="3）隔离性（Isolation，又称独立性）"></a>3）隔离性（Isolation，又称独立性）</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">数据库允许多个并发事务同时对其数据进行读写和修改的能力。<br>隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。<br></code></pre></td></tr></table></figure>

<h6 id="4）持久性（Durability）"><a href="#4）持久性（Durability）" class="headerlink" title="4）持久性（Durability）"></a>4）持久性（Durability）</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">事务处理结束后，对数据的修改是永久的，即便系统故障也不会丢失。<br></code></pre></td></tr></table></figure>

<h5 id="2-事务控制语句"><a href="#2-事务控制语句" class="headerlink" title="2. 事务控制语句"></a>2. 事务控制语句</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">MySQL数据库事务默认都是自动提交的，即执行完<span class="hljs-keyword">SQL</span>语句后就会马上执行<span class="hljs-keyword">COMMIT</span>操作。<br>显示地开启、提交事务<br><br><span class="hljs-keyword">BEGIN</span> / <span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span> ： 开启一个事务。<br><span class="hljs-keyword">COMMIT</span> / <span class="hljs-keyword">COMMIT</span> <span class="hljs-keyword">WORK</span> ：提交事务，使已对数据库进行的所有修改成为永久性的。<br><span class="hljs-keyword">ROLLBACK</span> / <span class="hljs-keyword">ROLLBACK</span> <span class="hljs-keyword">WORK</span> ：回滚事务，撤销正在进行的所有未提交的修改。<br><br><span class="hljs-keyword">SAVEPOINT</span> identifier ：允许在事务中创建一个保存点，一个事务中可以有多个<span class="hljs-keyword">SAVEPOINT</span>。<br><span class="hljs-keyword">RELEASE</span> <span class="hljs-keyword">SAVEPOINT</span> identifier ：删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常。<br><span class="hljs-keyword">ROLLBACK</span> <span class="hljs-keyword">TO</span> identifier ：把事务回滚到标记点。<br><span class="hljs-keyword">SAVEPOINT</span> 是在数据库事务处理中实现“子事务”，也称嵌套事务的方法。<br><br>事务可以回滚到<span class="hljs-keyword">SAVEPOINT</span>而不影响<span class="hljs-keyword">SAVEPOINT</span>创建前的变化，不需要放弃整个事务。<br><span class="hljs-keyword">SAVEPOINT</span> savepoint_name;     # 声明一个<span class="hljs-keyword">savepoint</span> 。<br><span class="hljs-keyword">ROLLBACK</span> <span class="hljs-keyword">TO</span> savepoint_name;   # 回滚到 <span class="hljs-keyword">savepoint</span> 。<br><span class="hljs-keyword">RELEASE</span> <span class="hljs-keyword">SAVEPOINT</span> savepoint_name;   # 删除指定保留点 。<br><br><span class="hljs-keyword">SET</span> <span class="hljs-keyword">TRANSACTION</span> ：用来设置事务的隔离级别。<br><br>MySQL事务处理的两种方法<br><span class="hljs-number">1</span>） 用<span class="hljs-keyword">BEGIN</span>, <span class="hljs-keyword">ROLLBACK</span>, <span class="hljs-keyword">COMMIT</span>实现。<br>    <span class="hljs-keyword">BEGIN</span> 开始一个事务。<br>    <span class="hljs-keyword">ROLLBACK</span> 回滚事务。<br>    <span class="hljs-keyword">COMMIT</span> 提交事务。<br><br><span class="hljs-number">2</span>）直接用<span class="hljs-keyword">SET</span>来改变MySQL的自动提交模式<br><span class="hljs-keyword">SET</span> AUTOCOMMIT = <span class="hljs-number">0</span>  ：禁止自动提交。<br><span class="hljs-keyword">SET</span> AUTOCOMMIT = <span class="hljs-number">1</span>  ：开启自动提交。<br></code></pre></td></tr></table></figure>

<h4 id="B．数据库并发性"><a href="#B．数据库并发性" class="headerlink" title="B．数据库并发性"></a>B．数据库并发性</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">不同的数据库隔离级别不同，使用加锁的方式也不同。<br>MySQL支持四种事务隔离级别，默认隔离级别是（RR， <span class="hljs-keyword">Repeatable</span> <span class="hljs-keyword">Read</span>）。<br>Oracle 支持两种事务隔离级别（RC 与 <span class="hljs-keyword">Serializable</span>），默认隔离级别是（RC， <span class="hljs-keyword">Read</span> <span class="hljs-keyword">Committed</span>）。<br></code></pre></td></tr></table></figure>

<h5 id="1-读数据的概念"><a href="#1-读数据的概念" class="headerlink" title="1. 读数据的概念"></a>1. 读数据的概念</h5><h6 id="1-脏读（Dirty-Reads）"><a href="#1-脏读（Dirty-Reads）" class="headerlink" title="1) 脏读（Dirty Reads）"></a>1) 脏读（Dirty Reads）</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">就是对脏数据的读取，脏数据指的是未提交的数据。<br></code></pre></td></tr></table></figure>

<h6 id="2-不可重复读（Non-Repeatable-Reads）"><a href="#2-不可重复读（Non-Repeatable-Reads）" class="headerlink" title="2) 不可重复读（Non-Repeatable Reads）"></a>2) 不可重复读（Non-Repeatable Reads）</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">一个事务先后读取同一条记录，两次读取的数据不同。<br></code></pre></td></tr></table></figure>

<h6 id="3-幻读（Phantom-Reads）"><a href="#3-幻读（Phantom-Reads）" class="headerlink" title="3) 幻读（Phantom Reads）"></a>3) 幻读（Phantom Reads）</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">一个事务按相同的查询条件重新读取以前检索过的数据，却发现其它事务插入了满足其查询条件的新数据。<br></code></pre></td></tr></table></figure>

<h6 id="例：存在两个事务（T1-T2）同时运行"><a href="#例：存在两个事务（T1-T2）同时运行" class="headerlink" title="例：存在两个事务（T1, T2）同时运行"></a>例：存在两个事务（T1, T2）同时运行</h6><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-built_in">T1</span>读取了已经被<span class="hljs-built_in">T2</span>修改但还未提交的字段，由于某种原因，<span class="hljs-built_in">T2</span>事务回滚，则<span class="hljs-built_in">T1</span>读取的内容是临时且无效的；这就是脏读。<br><span class="hljs-built_in">T1</span>读取一个字段，之后<span class="hljs-built_in">T2</span>更新了该字段，<span class="hljs-built_in">T1</span>再次读取该字段值时则读取到的是被<span class="hljs-built_in">T2</span>更新后的新值；这就是不可重复读。<br><span class="hljs-built_in">T1</span>从一个表中读取了一个字段，然后<span class="hljs-built_in">T2</span>在该表中插入了一些新的行，之后<span class="hljs-built_in">T1</span>再次读取该表时会多出几行。这就是幻读。<br></code></pre></td></tr></table></figure>

<h5 id="2-数据库隔离级别"><a href="#2-数据库隔离级别" class="headerlink" title="2. 数据库隔离级别"></a>2. 数据库隔离级别</h5><h6 id="1-Read-UnCommitted（读未提交数据）"><a href="#1-Read-UnCommitted（读未提交数据）" class="headerlink" title="1) Read UnCommitted（读未提交数据）"></a>1) Read UnCommitted（读未提交数据）</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">允许事务读取未被其它事务提交的变更数据。<br>会出现脏读、不可重复读和幻读问题，隔离级别最低（读不锁）。<br></code></pre></td></tr></table></figure>

<h6 id="2-Read-Committed（读已提交数据）"><a href="#2-Read-Committed（读已提交数据）" class="headerlink" title="2) Read Committed（读已提交数据）"></a>2) Read Committed（读已提交数据）</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">允许事务读取已经被其它事务提交的变更数据。<br>可避免脏读，扔会出现不可重复读和幻读问题（读锁）。<br></code></pre></td></tr></table></figure>

<h6 id="3-Repeatable-Read（可重复读）"><a href="#3-Repeatable-Read（可重复读）" class="headerlink" title="3) Repeatable Read（可重复读）"></a>3) Repeatable Read（可重复读）</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">确保事务可以多次从一个字段中读取相同的值。<br>在此事务持续期间，禁止其它事务对此字段的更新。<br>可以避免脏读和不可重复读，扔会出现幻读问题，RR隔离级别对读取到的记录加锁（写锁）。<br></code></pre></td></tr></table></figure>

<h6 id="4-Serializable（序列化）"><a href="#4-Serializable（序列化）" class="headerlink" title="4) Serializable（序列化）"></a>4) Serializable（序列化）</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">确保事务可以从一个表中读取相同的行，在这个事务持续期间，禁止其它事务对该表执行插入、更新和删除操作。<br>可避免所有并发问题，但性能非常低。<br>所有的<span class="hljs-keyword">SELECT</span>语句都被隐士的转换成<span class="hljs-keyword">SELECT</span> …… <span class="hljs-keyword">LOCK</span> <span class="hljs-keyword">IN</span> <span class="hljs-keyword">SHARE MODE</span>。<br>即读取使用表级共享锁，读写相互都会阻塞，隔离级别最高（表级锁）。<br></code></pre></td></tr></table></figure>

<h5 id="3-数据库的存储引擎"><a href="#3-数据库的存储引擎" class="headerlink" title="3. 数据库的存储引擎"></a>3. 数据库的存储引擎</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">常见的数据库存储引擎有：（1）MyISAM    （2）InnoDB 。<br></code></pre></td></tr></table></figure>

<h6 id="1-MyISAM"><a href="#1-MyISAM" class="headerlink" title="1) MyISAM"></a>1) MyISAM</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">支持表级锁。<br>适用场景：读多写少，硬件配置不高。<br></code></pre></td></tr></table></figure>

<h6 id="2-InnoDB-（MySQL默认存储引擎）"><a href="#2-InnoDB-（MySQL默认存储引擎）" class="headerlink" title="2) InnoDB （MySQL默认存储引擎）"></a>2) InnoDB （MySQL默认存储引擎）</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">支持表级、行级（默认）锁。<br>适用场景：支持事务、支持外键，即有读又有写的业务中。<br></code></pre></td></tr></table></figure>

<h5 id="4-数据库锁"><a href="#4-数据库锁" class="headerlink" title="4. 数据库锁"></a>4. 数据库锁</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">锁主要用于多用户环境下保证数据库完整性和一致性。<br></code></pre></td></tr></table></figure>

<h6 id="1-锁按使用方式划分"><a href="#1-锁按使用方式划分" class="headerlink" title="1) 锁按使用方式划分"></a>1) 锁按使用方式划分</h6><h6 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h6><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">每次去拿数据的时候都认为别人不会修改，所以不会上锁。<br>但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。<br>如果发生冲突了，则返回用户错误信息，让用户决定如何去做。<br>大多是基于数据版本（<span class="hljs-keyword">Version</span>）记录机制实现。<br></code></pre></td></tr></table></figure>

<h6 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">每次去拿数据的时候都认为别人会修改，所以每次拿数据的时候都会上锁。<br></code></pre></td></tr></table></figure>

<h6 id="2-锁按级别划分"><a href="#2-锁按级别划分" class="headerlink" title="2) 锁按级别划分"></a>2) 锁按级别划分</h6><h6 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">共享锁（<span class="hljs-keyword">Share</span> <span class="hljs-keyword">Lock</span>），S锁，也叫读锁，用于所有的只读数据操作。<br>共享锁是非独占的，允许多个并发事务读取其锁定的资源。<br><br>共享锁性质：<br>多个事务可封锁同一个共享页。<br>任何事务都不能修改该页。<br>通常是该页被读取完毕，S锁立即被释放。<br></code></pre></td></tr></table></figure>

<h6 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a>排他锁</h6><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tp">排他锁（Exclusive Lock），<span class="hljs-keyword">X</span>锁，也叫写锁，用于对数据进行写操作。<br>如果一个事务对对象加了排他锁，其它事务就不能再给它加任何锁了。<br><br>排他锁性质<br>仅允许一个事务封锁此页。<br>其它任何事务必须等到<span class="hljs-keyword">X</span>锁被释放才能对该页进行访问。<br><span class="hljs-keyword">X</span>锁一直到事务结束才能被释放。<br></code></pre></td></tr></table></figure>

<h6 id="3-锁按粒度划分（MySQL）"><a href="#3-锁按粒度划分（MySQL）" class="headerlink" title="3) 锁按粒度划分（MySQL）"></a>3) 锁按粒度划分（MySQL）</h6><h6 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">锁的作用范围是整张表。<br>开销小、加锁快，不会出现死锁。<br>锁定粒度大，发生锁冲突的概率最高，并发度最低。<br></code></pre></td></tr></table></figure>

<h6 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">锁的作用范围是行级别。<br>开销大、加锁慢，会出现死锁。<br>锁定粒度最小，发生锁冲突的概率最低，并发度最高。<br></code></pre></td></tr></table></figure>

<h6 id="页级锁"><a href="#页级锁" class="headerlink" title="页级锁"></a>页级锁</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">锁的作用范围是整个页面。<br>开销和加锁时间界于表锁和行锁之间，会出现死锁，锁定粒度界于表锁和行锁之间，并发度一般。<br></code></pre></td></tr></table></figure>

<h6 id="4-意向锁"><a href="#4-意向锁" class="headerlink" title="4) 意向锁"></a>4) 意向锁</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">意向锁是InnoDB自动加的，不需要用户干预。<br></code></pre></td></tr></table></figure>

<h6 id="意向共享锁（Intention-Shared-Lock）"><a href="#意向共享锁（Intention-Shared-Lock）" class="headerlink" title="意向共享锁（Intention Shared Lock）"></a>意向共享锁（Intention Shared Lock）</h6><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">表示事务准备给数据行加入共享锁，也就是说一个数据行加共享锁前必须先取得该表的<span class="hljs-keyword">IS</span>锁。<br></code></pre></td></tr></table></figure>

<h6 id="意向排它锁（Intention-Exclusive-Lock）"><a href="#意向排它锁（Intention-Exclusive-Lock）" class="headerlink" title="意向排它锁（Intention Exclusive Lock）"></a>意向排它锁（Intention Exclusive Lock）</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">表示事务准备给数据行加入排它锁，也就是说一个数据行加排它锁前必须先取得该表的IX锁。<br></code></pre></td></tr></table></figure>

<h5 id="5-锁实现方式"><a href="#5-锁实现方式" class="headerlink" title="5. 锁实现方式"></a>5. 锁实现方式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">当一个事务获得对一个表的写锁后，只有持有锁的事务可以对表进行更新操作，其它事务的读、写操作都会等待，直到锁被释放为止。<br>当一个事务获取对一个表的读锁后，其它事务也可以获取此表的读操作权限，但其它事务不能获取此表的写操作权限，直到锁被释放为止。<br></code></pre></td></tr></table></figure>

<h6 id="1-行级锁实现方式"><a href="#1-行级锁实现方式" class="headerlink" title="1) 行级锁实现方式"></a>1) 行级锁实现方式</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">行级锁不是锁记录，而是锁索引；只有通过索引条件检索数据，才能使用行级锁。<br></code></pre></td></tr></table></figure>

<h6 id="隐式加锁"><a href="#隐式加锁" class="headerlink" title="隐式加锁"></a>隐式加锁</h6><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">对于<span class="hljs-keyword">UPDATE</span>、<span class="hljs-keyword">DELETE</span>、<span class="hljs-keyword">INSERT</span>语句，InnoDB会自动给涉及数据集加排他锁。<br>对于普通<span class="hljs-keyword">SELECT</span>语句，InnoDB不会加任何锁。<br></code></pre></td></tr></table></figure>

<h6 id="显式加锁"><a href="#显式加锁" class="headerlink" title="显式加锁"></a>显式加锁</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> tb_name <span class="hljs-keyword">WHERE</span> …… <span class="hljs-keyword">LOCK</span> <span class="hljs-keyword">IN</span> <span class="hljs-keyword">SHARE MODE</span>;    # 加共享锁。<br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> tb_name <span class="hljs-keyword">WHERE</span> …… <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;              # 加排他锁。<br></code></pre></td></tr></table></figure>

<h6 id="2-表级锁实现方式"><a href="#2-表级锁实现方式" class="headerlink" title="2) 表级锁实现方式"></a>2) 表级锁实现方式</h6><h6 id="隐式加锁-1"><a href="#隐式加锁-1" class="headerlink" title="隐式加锁"></a>隐式加锁</h6><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">在执行查询语句<span class="hljs-keyword">SELECT</span>前，会自动给涉及的所有表加读锁。<br>在执行更新操作<span class="hljs-keyword">UPDATE</span>、<span class="hljs-keyword">DELETE</span>、<span class="hljs-keyword">INSERT</span>前，会自动给涉及的表加写锁。<br></code></pre></td></tr></table></figure>

<h6 id="显式加锁-1"><a href="#显式加锁-1" class="headerlink" title="显式加锁"></a>显式加锁</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">LOCK</span> <span class="hljs-keyword">TABLE</span> tb_name <span class="hljs-keyword">WRITE</span>;     # 加写锁<br><span class="hljs-keyword">LOCK</span> <span class="hljs-keyword">TABLE</span> tb_name <span class="hljs-keyword">READ</span>；    # 加读锁<br><br>UNLOCK <span class="hljs-keyword">TABLES</span>；     # 释放锁<br></code></pre></td></tr></table></figure>

<h5 id="6-InnoDB锁机制"><a href="#6-InnoDB锁机制" class="headerlink" title="6. InnoDB锁机制"></a>6. InnoDB锁机制</h5><h6 id="1-Record-Lock"><a href="#1-Record-Lock" class="headerlink" title="1) Record Lock"></a>1) Record Lock</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">行锁，单条索引记录加锁，<span class="hljs-type">Record</span> <span class="hljs-keyword">Lock</span>锁住的是索引，而非记录本身。<br></code></pre></td></tr></table></figure>

<h6 id="2-Gap-Lock"><a href="#2-Gap-Lock" class="headerlink" title="2) Gap Lock"></a>2) Gap Lock</h6><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cos">间隙锁，在索引记录之间的间隙中加锁，或者是在某一条索引记录之前或者之后加锁，并不包括该索引记录本身。<br>Gap <span class="hljs-keyword">Lock</span> 是针对事务隔离级别为RR或以上。<br>Gap <span class="hljs-keyword">Lock</span>在InnoDB的唯一作用就是防止其它事务的插入操作，以此防止幻读的发生。<br>Gap <span class="hljs-keyword">Lock</span> 一般针对非唯一索引而言。<br></code></pre></td></tr></table></figure>

<h6 id="3-Next-key-Lock"><a href="#3-Next-key-Lock" class="headerlink" title="3) Next-key Lock"></a>3) Next-key Lock</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Next-key <span class="hljs-keyword">Lock</span>是<span class="hljs-type">Record</span> <span class="hljs-keyword">Lock</span>和Gap <span class="hljs-keyword">Lock</span>的结合，即锁住了记录本身，还要锁住索引之间的间隙。<br>MySQL 的事务隔离级别默认是RR，若innodb_locks_unsafe_for_binlog参数为<span class="hljs-number">0</span>，默认采用Next-key <span class="hljs-keyword">Lock</span>。<br>Next-key <span class="hljs-keyword">Lock</span>是行锁和间隙锁的组合，当InnoDB扫描索引记录的时候，会首先对索引记录加上行锁（<span class="hljs-type">Record</span> <span class="hljs-keyword">Lock</span>），再对索引记录两边的间隙加上间隙锁（Gap <span class="hljs-keyword">Lock</span>）。<br><br>加上间隙锁之后，其它事务就不能在这个间隙修改或者插入记录。<br></code></pre></td></tr></table></figure>

<h5 id="7-死锁"><a href="#7-死锁" class="headerlink" title="7. 死锁"></a>7. 死锁</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，他们都将无法推进下去。<br></code></pre></td></tr></table></figure>

<h6 id="1-产生死锁的原因"><a href="#1-产生死锁的原因" class="headerlink" title="1) 产生死锁的原因"></a>1) 产生死锁的原因</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">系统的资源不足。<br>代码执行的顺序不合适。<br>资源分配不当。<br></code></pre></td></tr></table></figure>

<h6 id="2-产生死锁的必要条件"><a href="#2-产生死锁的必要条件" class="headerlink" title="2) 产生死锁的必要条件"></a>2) 产生死锁的必要条件</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">互斥条件：一个资源每次只能被一个进程使用。<br>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。<br>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。<br></code></pre></td></tr></table></figure>

<h6 id="3-减少死锁发生"><a href="#3-减少死锁发生" class="headerlink" title="3) 减少死锁发生"></a>3) 减少死锁发生</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">按同一顺序访问对象。<br>避免事务中的用户交互。<br>保持事务简短并在一个批处理中。<br>使用低隔离级别。<br>使用绑定连接。<br></code></pre></td></tr></table></figure>

<h5 id="8-MVCC多版本并发控制"><a href="#8-MVCC多版本并发控制" class="headerlink" title="8. MVCC多版本并发控制"></a>8. MVCC多版本并发控制</h5><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">MVCC</span>：<span class="hljs-variable">Multi</span><span class="hljs-operator">-</span><span class="hljs-built_in">Version</span> <span class="hljs-variable">Concurrency</span> <span class="hljs-built_in">Control</span> 多版本并发控制。<br><span class="hljs-variable">MVCC</span>是一种并发控制的方法，一般在数据库管理系统中实现对数据库高并发场景下的吞吐性能。<br></code></pre></td></tr></table></figure>

<h6 id="1-MVCC原理"><a href="#1-MVCC原理" class="headerlink" title="1) MVCC原理"></a>1) MVCC原理</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">MVCC的实现，通过保存数据在某个时间点的快照来实现的。<br>在每行记录后面保存两个隐藏的列，一列保存了行的创建时间，另一列保存了行的过期时间（或删除时间）。<br>这里存储的时间并不是实际的时间值，而是系统版本号。<br>每开始一个新事物，系统版本号都会自动递增。<br>事务开始时刻的系统版本号会作为事务的版本号，用来与查询到的每行记录的版本号进行比较。<br></code></pre></td></tr></table></figure>

<h6 id="2-MVCC特征"><a href="#2-MVCC特征" class="headerlink" title="2) MVCC特征"></a>2) MVCC特征</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">每行数据都存在一个版本，每次数据更新时都更新该版本。<br>修改时<span class="hljs-keyword">copy</span>出当前版本进行修改，各个事务之间互不干扰。<br>保存时比较版本号，如果成功（<span class="hljs-keyword">commit</span>），则覆盖原纪录，失败则放弃<span class="hljs-keyword">copy</span>（<span class="hljs-keyword">rollback</span>）。<br></code></pre></td></tr></table></figure>

<h6 id="3-MVCC实现"><a href="#3-MVCC实现" class="headerlink" title="3) MVCC实现"></a>3) MVCC实现</h6><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs vim">在每一行数据中额外保存两个隐藏的列：（<span class="hljs-number">1</span>）DATA_TRX_ID   （<span class="hljs-number">2</span>）DATA_ROLL_PTR。<br><br>DATA_TRX_ID<br>记录最近一次修改（<span class="hljs-keyword">insert</span> / <span class="hljs-keyword">update</span>）本行纪录的事务id，大小为<span class="hljs-number">6</span>字节。<br><br>DATA_ROLL_PTR<br>指向该行回滚段（rollback segment）的<span class="hljs-keyword">undo</span> <span class="hljs-built_in">log</span> record（撤销日志记录）指针，大小为<span class="hljs-number">7</span>字节。<br>如果一行记录被更新，则<span class="hljs-keyword">undo</span> <span class="hljs-built_in">log</span> record 包含“重建该行记录被更新之前内容”所必须的信息。<br>InnoDB便是通过这个指针找到之前版本的数据。<br>若该行记录上存储所有的旧版本，在<span class="hljs-keyword">undo</span>中都通过链表的形式组织。<br><br>如果表没有主键，则还会有一个隐藏的主键列 DB_ROW_ID。<br><br>DB_ROW_ID<br>行标识（隐藏单调自增ID），大小为<span class="hljs-number">6</span>字节，如果表没有主键，InnoDB会自动生成一个隐藏主键。<br><br>例：事务<span class="hljs-number">1</span>、事务<span class="hljs-number">2</span>， DATA_TRX_ID,   DATA_ROLL_PTR， DB_ROW_ID。<br>事务<span class="hljs-number">1</span>。<br>执行新增一条数据 <span class="hljs-keyword">insert</span>操作。<br>此时DB_ROW_ID = <span class="hljs-number">1</span>， DATA_TRX_ID = <span class="hljs-number">1</span>（系统版本号）,  DATA_ROLL_PTR = NULL。<br><br>事务 <span class="hljs-number">2</span> 执行<span class="hljs-keyword">update</span>操作过程。<br>对DB_ROW_ID = <span class="hljs-number">1</span>这行记录加排它锁。<br>把该行<span class="hljs-keyword">copy</span>前的值拷贝到<span class="hljs-keyword">undo</span> <span class="hljs-built_in">log</span>中。<br>修改该行的值，这时会产生一个新版本号，更新DATA_TRX_ID为修改记录的事务ID。<br>将DATA_ROLL_PTR指向刚刚<span class="hljs-keyword">copy</span>到<span class="hljs-keyword">undo</span> <span class="hljs-built_in">log</span> 链中的旧版本记录，这样就能通过DATA_ROLL_PTR找到这条记录的历史版本；如果对同一行记录执行连续的UPDATE, <span class="hljs-keyword">undo</span> <span class="hljs-built_in">log</span>会组成一个链表，遍历这个链表可以看到这条记录的变迁。<br>记录<span class="hljs-keyword">redo</span> <span class="hljs-built_in">log</span>，包括<span class="hljs-keyword">undo</span> <span class="hljs-built_in">log</span>中的修改。<br></code></pre></td></tr></table></figure>

<h6 id="4-RR隔离级别下，MVCC具体的操作流程。"><a href="#4-RR隔离级别下，MVCC具体的操作流程。" class="headerlink" title="4) RR隔离级别下，MVCC具体的操作流程。"></a>4) RR隔离级别下，MVCC具体的操作流程。</h6><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> ：InnoDB只查找版本早于当前事务版本的数据行；行的删除版本，要么未定义，要么大于当前事务版本号，这样可以确保事务读取到的行在事务开始之前未被删除。<br><span class="hljs-keyword">INSERT</span> ：InnoDB为插入的每一行保存当前系统版本号作为行版本号。<br><span class="hljs-keyword">DELETE</span> ：InnoDB为删除的每一行保存当前系统版本号作为删除标识，标记为删除、而不是实际删除。<br><span class="hljs-keyword">UPDATE</span> ：InnoDB会把原来的行复制一份到回滚段中，保存当前系统版本号作为行版本号，同时，保存当前系统版本号到原来的行作为删除标识。<br></code></pre></td></tr></table></figure>

<h3 id="三、InnoDB引擎的底层实现方式："><a href="#三、InnoDB引擎的底层实现方式：" class="headerlink" title="三、InnoDB引擎的底层实现方式："></a>三、InnoDB引擎的底层实现方式：</h3><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mel">InnoDB核心：（<span class="hljs-number">1</span>）日志   （<span class="hljs-number">2</span>）内存（缓存池（Buffer Pool））  (<span class="hljs-number">3</span>) 磁盘（Datafile）<br>InnoDB存储引擎有多个内存块，这些内存块组成了一个大的内存池。<br>后台线程主要负责刷新内存池中的数据，将已修改的数据刷新到磁盘。<br><br>当某个事务进行一次写操作时，InnoDB引擎将数据写入<span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span>后就会提交事务。<br>而非写入到磁盘（Datafile），之后InnoDB再异步地将新事务的数据异步地写入Datafile，真正存储起来。<br></code></pre></td></tr></table></figure>

<p><img src="https://segmentfault.com/img/remote/1460000022635992" srcset="/LinPresonBlog/img/loading.gif" lazyload alt="img"></p>
<h4 id="A．redo-log-和-undo-log-和-bin-log"><a href="#A．redo-log-和-undo-log-和-bin-log" class="headerlink" title="A．redo log 和 undo log 和 bin log"></a>A．redo log 和 undo log 和 bin log</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">用来恢复事务所对应的脏数据块的日志文件。<br></code></pre></td></tr></table></figure>

<h5 id="1-前滚-与-回滚"><a href="#1-前滚-与-回滚" class="headerlink" title="1. 前滚 与 回滚"></a>1. 前滚 与 回滚</h5><h6 id="前滚"><a href="#前滚" class="headerlink" title="前滚"></a>前滚</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">未完全提交的事务，即该事务已经被执行<span class="hljs-keyword">commit</span>命令了。<br>该事务所对应的脏数据块中只有一部分被写到磁盘上的数据文件中，一部分还在内存中。<br>若此时数据库实例崩溃，就需要用前滚来完成事务的完全提交。<br></code></pre></td></tr></table></figure>

<h6 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">未提交的事务，即该事务未被执行<span class="hljs-keyword">commit</span>命令。<br></code></pre></td></tr></table></figure>

<h5 id="2-Redo-log"><a href="#2-Redo-log" class="headerlink" title="2. Redo log"></a>2. Redo log</h5><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">重做日志，提供前滚操作。<br>Redo <span class="hljs-built_in">log</span> 通常是物理日志，记录的是数据页的物理修改，用来恢复提交后的物理数据页。<br>恢复数据页、且只能恢复到最后一次提交的位置。<br></code></pre></td></tr></table></figure>

<h6 id="Redo-log-包括两部分"><a href="#Redo-log-包括两部分" class="headerlink" title="Redo log 包括两部分"></a>Redo log 包括两部分</h6><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim">内存中的日志缓冲（<span class="hljs-keyword">redo</span> <span class="hljs-built_in">log</span> <span class="hljs-keyword">buffer</span>），该部分日志是易失性的。<br>磁盘上的重做日志文件（<span class="hljs-keyword">redo</span> <span class="hljs-built_in">log</span> <span class="hljs-keyword">file</span>），该部分日志是持久的。<br></code></pre></td></tr></table></figure>

<h5 id="3-Undo-log"><a href="#3-Undo-log" class="headerlink" title="3. Undo log"></a>3. Undo log</h5><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mel">回滚日志，提供回滚操作。<br>Undo <span class="hljs-keyword">log</span>用来回滚行记录到某个版本。<br><span class="hljs-keyword">undo</span> <span class="hljs-keyword">log</span>一般是逻辑日志，根据每行记录进行记录。<br></code></pre></td></tr></table></figure>

<h5 id="4-Bin-log"><a href="#4-Bin-log" class="headerlink" title="4. Bin log"></a>4. Bin log</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">二进制日志，记录对数据发生或潜在发生更改的<span class="hljs-keyword">SQL</span>语句，并以二进制的形式保存在磁盘中。<br>可以用来查看数据库的变更历史（具体的时间点所做的操作），数据库增量备份和恢复。<br><span class="hljs-keyword">Show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-operator">%</span>log_bin<span class="hljs-operator">%</span> ; <br></code></pre></td></tr></table></figure>

<h4 id="B．InnoDB内存"><a href="#B．InnoDB内存" class="headerlink" title="B．InnoDB内存"></a>B．InnoDB内存</h4><h5 id="1-InnoDB线程"><a href="#1-InnoDB线程" class="headerlink" title="1. InnoDB线程"></a>1. InnoDB线程</h5><h6 id="Master-Thread"><a href="#Master-Thread" class="headerlink" title="Master Thread"></a>Master Thread</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">最核心的线程，主要负责将缓存池中的数据异步刷新到磁盘，保证数据的一致性。<br></code></pre></td></tr></table></figure>

<h6 id="IO-Thread"><a href="#IO-Thread" class="headerlink" title="IO Thread"></a>IO Thread</h6><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">IO <span class="hljs-keyword">Thread</span> 主要负责大量的异步IO来处理写IO请求。<br></code></pre></td></tr></table></figure>

<h6 id="Purge-Thread"><a href="#Purge-Thread" class="headerlink" title="Purge Thread"></a>Purge Thread</h6><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">Purge <span class="hljs-keyword">Thread</span>回收已经使用并分配的undo页，InnoDB支持多个Purge <span class="hljs-keyword">Thread</span>，这样做可以加快undo页的回收。<br></code></pre></td></tr></table></figure>

<h6 id="Page-Cleaner-Thread"><a href="#Page-Cleaner-Thread" class="headerlink" title="Page Cleaner Thread"></a>Page Cleaner Thread</h6><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">Page Cleaner Thread是将之前版本中脏页的刷新操作都放入单独的线程中来完成，减轻<span class="hljs-keyword">Master</span> <span class="hljs-title">Thread</span>的工作及对于用户查询线程的阻塞。<br></code></pre></td></tr></table></figure>

<h5 id="2-InnoDB内存模型"><a href="#2-InnoDB内存模型" class="headerlink" title="2. InnoDB内存模型"></a>2. InnoDB内存模型</h5><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">InnoDB</span>引擎使用缓存池技术来提高数据库的整体性能。<br><span class="hljs-attribute">InnoDB</span>中缓存池页的大小默认为<span class="hljs-number">16</span>KB。<br></code></pre></td></tr></table></figure>

<h6 id="计算机科学中著名的局部性原理"><a href="#计算机科学中著名的局部性原理" class="headerlink" title="计算机科学中著名的局部性原理"></a>计算机科学中著名的局部性原理</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">当一个数据被用到时，其附近的数据也通常会马上被使用，程序运行期间所需要的数据通常比较集中。<br></code></pre></td></tr></table></figure>

<h6 id="内存-与-磁盘"><a href="#内存-与-磁盘" class="headerlink" title="内存 与 磁盘"></a>内存 与 磁盘</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">主存和磁盘是以页为单位交换数据。<br>当程序要读取的数据不在主存中时，会触发一个缺页异常。<br>此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中。<br>然后异常返回，程序继续运行。<br>数据库、内存、磁盘<br>在数据库中进行读取页的操作时，首先将从磁盘读到的页存放在缓存池中。<br>下一次读取相同的页时，首先判断页是不是在缓存池中。<br>若在、称该页在缓存池中被命中，直接读取该页。<br>否则、读取磁盘上的页。<br><br>对于数据库中页的修改操作，首先修改在缓存池中的页，然后再以一定的频率刷新到磁盘。 <br></code></pre></td></tr></table></figure>

<h5 id="3-缓存池（Buffer-Pool）"><a href="#3-缓存池（Buffer-Pool）" class="headerlink" title="3. 缓存池（Buffer Pool）"></a>3. 缓存池（Buffer Pool）</h5><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade">为了更好的管理这些被缓存的页，InnoDB为每一个缓存页都创建了一些控制信息（控制块）。<br>这些控制信息包括该页所属的表空间编号、页号、页在<span class="hljs-built_in">Buffer</span> Pool中的地址、锁信息、LSN信息等。<br>每个缓存页对应一个控制块，每个控制块占用的内存大小是相同的，它们都被放到<span class="hljs-built_in">Buffer</span> Pool中，如下图。<br></code></pre></td></tr></table></figure>

<p><img src="https://segmentfault.com/img/remote/1460000022635987" srcset="/LinPresonBlog/img/loading.gif" lazyload alt="img"></p>
<h5 id="4-Free-List（空闲链表）"><a href="#4-Free-List（空闲链表）" class="headerlink" title="4. Free List（空闲链表）"></a>4. Free List（空闲链表）</h5><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade">启动MySQL服务器时，需要对<span class="hljs-built_in">Buffer</span> Pool进行初始化，将<span class="hljs-built_in">Buffer</span> Pool划分成若干对控制块和缓存页。<br>随着程序的运行，会不断的将磁盘上的页缓存到<span class="hljs-built_in">Buffer</span> Pool中，但如何管理<span class="hljs-built_in">Buffer</span> Pool中空闲的缓存页呢？<br>使用Free List（空闲链表）来管理空闲的缓存页，如下图。<br></code></pre></td></tr></table></figure>

<p><img src="https://segmentfault.com/img/remote/1460000022635989" srcset="/LinPresonBlog/img/loading.gif" lazyload alt="img"></p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">Free</span> List控制信息：包含链表的头结点地址、尾结点地址、以及当前链表中结点的数量。<br>每个<span class="hljs-keyword">Free</span> List的结点中都记录了某个缓存页控制块的地址。<br>每个缓存页控制块都记录着对应的缓存页地址。<br><br>每当需要从磁盘中加载一个页到Buffer Pool中时，就从<span class="hljs-keyword">Free</span> List中取一个空闲的缓存页，并且把该缓存页对应的控制块的信息填上，然后把该缓存页对应的<span class="hljs-keyword">Free</span> List结点从<span class="hljs-keyword">Free</span> List链表中删除。<br></code></pre></td></tr></table></figure>

<h5 id="5-Buffer-Pool-清理机制"><a href="#5-Buffer-Pool-清理机制" class="headerlink" title="5. Buffer Pool 清理机制"></a>5. Buffer Pool 清理机制</h5><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arcade">缓存命中率：假设一共访问了n次页，那么被访问的页已经在缓存中的次数除以n就是缓存命中率。<br><br>InnoDB <span class="hljs-built_in">Buffer</span> Pool采用经典的LRU算法进行页面淘汰，以提高缓存命中率。<br>LRU（Least Recently Used）：最近最少使用，用来管理缓存池中页的可用性。<br>如果该页不在<span class="hljs-built_in">Buffer</span> Pool中，在把该页从磁盘加载到<span class="hljs-built_in">Buffer</span> Pool中的缓存页时，就把该缓存页包装成结点塞到链表的头部。<br>如果该页在<span class="hljs-built_in">Buffer</span> Pool中，则直接把该页对应的LRU链表结点移动到链表的头部。<br><br>缺点<br>若遇一次全表扫描就把热数据给冲完了，就会导致<span class="hljs-built_in">Buffer</span> Pool污染问题，严重的降低了缓存命中率。<br><span class="hljs-built_in">Buffer</span> Pool中的所有数据页都被换了一次血，其它查询语句在执行时又得执行一次从磁盘加载到<span class="hljs-built_in">Buffer</span> Pool的操作。<br></code></pre></td></tr></table></figure>

<h6 id="midpoint-insertion-stategy"><a href="#midpoint-insertion-stategy" class="headerlink" title="midpoint insertion stategy"></a>midpoint insertion stategy</h6><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs haxe">InnoDB存储引擎对传统的LRU算法做了一些优化。<br>在InnoDB中加入了midpoint，新读到的页，虽然是最新访问的页。<br>但并不直接插入到LRU列表的首部，而是插入到LRU列表的midpoint位置。<br>默认配置插入到列表长度的 <span class="hljs-number">5</span>/<span class="hljs-number">8</span> 处，midpoint由参数innodb_old_blocks_pct控制。<br><br>Midpoint之前的列表称之为<span class="hljs-keyword">new</span><span class="hljs-type"></span>列表，之后的列表称之为old列表。<br>可以简单的将<span class="hljs-keyword">new</span><span class="hljs-type"></span>列表中的页理解为最活跃的热点数据。<br><br>InnoDB存储引擎还引入了 innodb_old_blocks_time 来表示页读取到mid位置之后需要等待多久才会被加入到LRU列表的热端，可以通过设置该参数保证热点数据不轻易被刷出。<br></code></pre></td></tr></table></figure>

<h5 id="6-FLUSH链表（Flush-List）"><a href="#6-FLUSH链表（Flush-List）" class="headerlink" title="6. FLUSH链表（Flush List）"></a>6. FLUSH链表（Flush List）</h5><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">FLUSH</span>链表用来管理将页刷新回磁盘，缓存池中通过<span class="hljs-keyword">FLUSH</span> 链表存储需要被刷新到磁盘上的页（脏页）。<br>这里的脏页指的是此页被加载进Buffer Pool后第一次修改后的页。<br>只有第一次修改时才需要加入<span class="hljs-keyword">FLUSH</span>链表（第二次修改时已经存在了）。<br></code></pre></td></tr></table></figure>

<h5 id="7-LRU-List-Free-List-Flush-List-三者关系"><a href="#7-LRU-List-Free-List-Flush-List-三者关系" class="headerlink" title="7. LRU List, Free List, Flush List 三者关系"></a>7. LRU List, Free List, Flush List 三者关系</h5><p><img src="https://segmentfault.com/img/remote/1460000022635988" srcset="/LinPresonBlog/img/loading.gif" lazyload alt="img"></p>
<h5 id="8-Checkpoint-技术"><a href="#8-Checkpoint-技术" class="headerlink" title="8. Checkpoint 技术"></a>8. Checkpoint 技术</h5><h6 id="1-缩短数据库恢复时间。"><a href="#1-缩短数据库恢复时间。" class="headerlink" title="1) 缩短数据库恢复时间。"></a>1) 缩短数据库恢复时间。</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">redo <span class="hljs-keyword">log</span>中记录了<span class="hljs-keyword">Checkpoint</span>的位置。<br>这个点之前的页已经被刷新回磁盘，只需要对<span class="hljs-keyword">Checkpoint</span>之后的redo <span class="hljs-keyword">log</span>进行恢复。<br></code></pre></td></tr></table></figure>

<h6 id="2-缓存池不够用时，刷新脏页。"><a href="#2-缓存池不够用时，刷新脏页。" class="headerlink" title="2) 缓存池不够用时，刷新脏页。"></a>2) 缓存池不够用时，刷新脏页。</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">根据LRU算法，溢出最近最少使用页。<br>如果页为脏页，强制执行<span class="hljs-keyword">Checkpoint</span>，将脏页刷新回磁盘。<br></code></pre></td></tr></table></figure>

<h6 id="3-Redo-log不可用时，刷新脏页。"><a href="#3-Redo-log不可用时，刷新脏页。" class="headerlink" title="3) Redo log不可用时，刷新脏页。"></a>3) Redo log不可用时，刷新脏页。</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">由于redo <span class="hljs-keyword">log</span>是循环使用的，这部分对应的数据还未刷新到磁盘。<br>数据库恢复时，如果不需要这部分日志即可被覆盖。<br>如果需要，必须强制执行<span class="hljs-keyword">Checkpoint</span>，将缓存池中的页至少刷新到当前重做日志的位置。<br></code></pre></td></tr></table></figure>

<h6 id="InnoDB存储引擎内部，有两种Checkpoint"><a href="#InnoDB存储引擎内部，有两种Checkpoint" class="headerlink" title="InnoDB存储引擎内部，有两种Checkpoint"></a>InnoDB存储引擎内部，有两种Checkpoint</h6><h6 id="Sharp-Checkpoint（默认，-innodb-fast-shutdown-1）。"><a href="#Sharp-Checkpoint（默认，-innodb-fast-shutdown-1）。" class="headerlink" title="Sharp Checkpoint（默认， innodb_fast_shutdown=1）。"></a>Sharp Checkpoint（默认， innodb_fast_shutdown=1）。</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Sharp <span class="hljs-keyword">Checkpoint</span>发生在数据库关闭时，将所有的脏页都刷新回磁盘。<br>缺点：不适用于数据库运行时的刷新。<br></code></pre></td></tr></table></figure>

<h6 id="Fuzzy-Checkpoint。"><a href="#Fuzzy-Checkpoint。" class="headerlink" title="Fuzzy Checkpoint。"></a>Fuzzy Checkpoint。</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Fuzzy <span class="hljs-keyword">Checkpoint</span>适用于数据库运行时刷新脏页，只刷新一部分脏页。<br>MasterThread <span class="hljs-keyword">Checkpoint</span><br>异步刷新，每秒或每<span class="hljs-number">10</span>秒从缓存池脏页列表刷新一定比例的页回磁盘。<br><br>FLUSH_LRU_LIST <span class="hljs-keyword">Checkpoint</span><br>若Buffer Pool中没有足够的空间时，根据LRU算法、溢出LRU列表尾端的页。<br>如果这些页有脏页，需要进行<span class="hljs-keyword">Checkpoint</span>（Page Cleaner Thread线程就是做这个事的）。<br>InnoDB存储引擎需要保证LRU列表中差不多有<span class="hljs-number">100</span>个空闲页可供使用。<br>Innodb_lru_scan_dept ：控制LRU列表中可用页的数量，默认<span class="hljs-number">1024</span>。<br><br>Asnc / Sync Flush <span class="hljs-keyword">Checkpoint</span><br>指重做日志不可用时，需要强制刷新页回磁盘。<br>此时的页是脏页列表（FLUSH LIST）中选取的。<br></code></pre></td></tr></table></figure>

<h6 id="LSN"><a href="#LSN" class="headerlink" title="LSN"></a>LSN</h6><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs abnf">事务日志中每条记录的编号。<br>InnoDB存储引擎，通过LSN（Log Sequence Number）来标记版本，LSN是<span class="hljs-number">8</span>字节的数字。<br><br>redo_lsn ：写入日志的 LSN。<br>Checkpoint_lsn ：刷新回磁盘的最新页 LSN。<br><br>Checkpoint_age = redo_lsn – checkpoint_lsn。<br>Async_water_mark = <span class="hljs-number">75</span>% * total_redo_file_size。<br>Sync_water_mark = <span class="hljs-number">90</span>% * total_redo_file_size。<br></code></pre></td></tr></table></figure>

<h6 id="Dirty-Page-too-much-Checkpoint"><a href="#Dirty-Page-too-much-Checkpoint" class="headerlink" title="Dirty Page too much Checkpoint"></a>Dirty Page too much Checkpoint</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">即脏页太多，强制<span class="hljs-keyword">checkpoint</span>，保证缓存池中有足够可用的页。<br>参数设置：innodb_max_dirty_pages_pct = <span class="hljs-number">75</span>。<br>表示：当缓存池中脏页的数量占<span class="hljs-number">75</span>%时，强制<span class="hljs-keyword">checkpoint</span>。<span class="hljs-number">1.0</span>x之后默认<span class="hljs-number">75</span>。<br></code></pre></td></tr></table></figure>

<p><img src="https://segmentfault.com/img/remote/1460000022635990" srcset="/LinPresonBlog/img/loading.gif" lazyload alt="img"></p>
<h4 id="C．InnoDB关键特性"><a href="#C．InnoDB关键特性" class="headerlink" title="C．InnoDB关键特性"></a>C．InnoDB关键特性</h4><h5 id="1-插入缓存（Insert-Buffer）"><a href="#1-插入缓存（Insert-Buffer）" class="headerlink" title="1. 插入缓存（Insert Buffer）"></a>1. 插入缓存（Insert Buffer）</h5><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">Insert </span><span class="hljs-keyword">Buffer的设计，对于非聚集索引的插入和更新操作，不是每次都直接插入到索引页中。</span><br><span class="hljs-keyword">而是先判断插入非聚集索引页是否在缓存池中。</span><br><span class="hljs-keyword">若存在则直接插入，若不存在则先放入一个Insert </span><span class="hljs-keyword">Buffer对象中。</span><br><span class="hljs-keyword"></span><br><span class="hljs-keyword">数据库这个非聚集的索引并没有插入到叶子结点（因为B+树只有叶子结点才存储数据），而是存放在另一个位置。</span><br><span class="hljs-keyword">然后再以一定的频率和情况进行Insert </span><span class="hljs-keyword">Buffer和辅助索引页子结点的merge（合并）操作。</span><br><span class="hljs-keyword">这时通常能将多个插入合并到一个操作中（因为在一个索引页中），这就大大提高了对于非聚集索引插入的性能。</span><br></code></pre></td></tr></table></figure>

<h6 id="使用Insert-Buffer需要满足两个条件"><a href="#使用Insert-Buffer需要满足两个条件" class="headerlink" title="使用Insert Buffer需要满足两个条件"></a>使用Insert Buffer需要满足两个条件</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">1) 索引是辅助索引。<br>2) 索引不是唯一的。<br></code></pre></td></tr></table></figure>

<h5 id="2-两次写操作"><a href="#2-两次写操作" class="headerlink" title="2. 两次写操作"></a>2. 两次写操作</h5><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vim">假设有这样一个场景，当数据库正在从内存向磁盘写一个数据页时，数据库宕机。<br>从而导致这个页只写了部分数据，这就是部分写失效，它会导致数据丢失。<br>这时是无法通过重做日志（<span class="hljs-keyword">redo</span> <span class="hljs-built_in">log</span>）恢复的。<br>因为重做日志记录是对页的物理修改，如果页本身已损坏，重做日志也无能为力。<br><br>如何解决以上问题 ？<br>为了解决以上问题，可以使用两次写操作。<br>因为在磁盘共享表空间中已有数据页副本拷贝，如果数据库在页写入数据文件的过程中宕机。<br>在实例恢复时，可以从共享表空间中找到该页副本，将其拷贝覆盖原有的数据页，再应用重做日志即可。<br><br>两次写原理。<br><span class="hljs-number">1</span>) 当刷新缓存池脏页时，并不直接写到数据文件中，而是先拷贝至内存中的两次写缓存区。<br><span class="hljs-number">2</span>) 接着从两次写缓存区分两次写入磁盘共享表空间中，每次写入<span class="hljs-number">1</span>MB。<br><span class="hljs-number">3</span>) 待第<span class="hljs-number">2</span>步完成后，再将两次写缓存区写入数据文件。<br><br>两次写需要额外添加两个部分。<br><span class="hljs-number">1</span>) 内存中的两次写缓存（doublewrite <span class="hljs-keyword">buffer</span>），大小为<span class="hljs-number">2</span>MB。<br><span class="hljs-number">2</span>) 磁盘上共享表空间中连续的<span class="hljs-number">128</span>页，大小也为<span class="hljs-number">2</span>MB。<br><br>InnoDB默认开启两次写功能，可以通过skip_innodb_doublewrite禁用两次写功能。<br></code></pre></td></tr></table></figure>

<p><img src="https://segmentfault.com/img/remote/1460000022635991" srcset="/LinPresonBlog/img/loading.gif" lazyload alt="img"></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/LinPresonBlog/categories/MySql/">MySql</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/LinPresonBlog/tags/MySql/">MySql</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/LinPresonBlog/2021/08/20/MySql/MySql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E4%B8%8E%E8%AE%BE%E8%AE%A1/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Mysql基本知识与设计</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/LinPresonBlog/2021/03/22/Hexo/Hello-Hexo/">
                        <span class="hidden-mobile">学习使用Hexo</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
    
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/LinPresonBlog/js/events.js" ></script>
<script  src="/LinPresonBlog/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/LinPresonBlog/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/LinPresonBlog/js/local-search.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/LinPresonBlog/js/boot.js" ></script>


</body>
</html>
